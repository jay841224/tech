{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/tech/2025/05/14/hello-world/"},{"title":"Java CircuitBreaker 斷路器機制全解析與實戰","text":"CircuitBreaker 斷路器設計原理在分散式系統或微服務架構中，**斷路器（CircuitBreaker）**是一種保護機制，能即時阻斷異常服務的連鎖失敗，防止雪崩效應，提升系統穩定性。 狀態說明CircuitBreaker 通常分為三種正常狀態： CLOSED（關閉）：正常通過，監控錯誤率。 OPEN（開啟）：發現異常，短路後續請求。 HALF_OPEN（半開）：進入觀察，部分請求放行檢查服務恢復狀態。 也有三種特殊狀態： METRICS_ONLY：僅記錄統計資訊。 DISABLED：完全停用斷路器。 FORCED_OPEN：強制開啟，全部短路。 狀態切換機制斷路器會根據滑動視窗（Sliding Window）的統計數據切換狀態。滑動視窗分為兩種型態： 計數型（Count-based）：統計最近 N 筆呼叫結果。 時間型（Time-based）：統計最近 N 毫秒內呼叫結果。 每當滑動視窗內的失敗率或慢呼叫率超過設定閾值，斷路器就會切換為 OPEN，直接拒絕後續請求（拋出 CallNotPermittedException）。 注意： CircuitBreaker 並不會限制同時有多少請求進行。假如同時有 20 個執行緒呼叫函式，即使滑動視窗大小為 15，這 20 個請求都會通過。如果你要限制同時執行數量，請結合 Bulkhead 使用。 執行緒安全設計 狀態變更透過 AtomicReference 原子操作，確保 thread-safe。 滑動視窗的寫入／讀取有同步控制，避免狀態競爭與數據錯亂。 只有一個執行緒能變更狀態或滑動視窗。 CircuitBreaker 常用設定說明 設定屬性 預設值 說明 failureRateThreshold 50 (%) 失敗率超過此百分比就開啟斷路器 slowCallRateThreshold 100 (%) 慢呼叫率超過此百分比也會開啟斷路器 slowCallDurationThreshold 60000 ms 超過這個執行時間視為慢呼叫 permittedNumberOfCallsInHalfOpenState 10 半開狀態下允許的最大請求次數 maxWaitDurationInHalfOpenState 0 ms 半開狀態下的最長等待時間（0 表示無限等待） slidingWindowType COUNT_BASED COUNT_BASED：以次數統計，TIME_BASED：以時間統計 slidingWindowSize 100 視窗大小（以次數或毫秒為單位，依視窗型態而異） minimumNumberOfCalls 100 視窗內最少需要多少呼叫才會判斷是否跳閘 waitDurationInOpenState 60000 ms OPEN 狀態多久後允許進入 HALF_OPEN automaticTransitionFromOpenToHalfOpenEnabled false 是否自動切到 HALF_OPEN（true：計時自動切換，false：須等呼叫進來才切換） recordExceptions 空列表 指定哪些 Exception 要被記錄為失敗 ignoreExceptions 空列表 指定哪些 Exception 要忽略，不列入計算 recordFailurePredicate throwable→true 自訂失敗判斷邏輯 ignoreExceptionPredicate throwable→false 自訂忽略判斷邏輯 YAML 設定範例（Spring Boot）12345678910111213141516171819resilience4j.circuitbreaker: configs: default: slidingWindowSize: 100 permittedNumberOfCallsInHalfOpenState: 10 waitDurationInOpenState: 10000 failureRateThreshold: 60 eventConsumerBufferSize: 10 registerHealthIndicator: true someShared: slidingWindowSize: 50 permittedNumberOfCallsInHalfOpenState: 10 instances: backendA: baseConfig: default waitDurationInOpenState: 5000 backendB: baseConfig: someShared slidingWindowSize: 5 註解與程式碼實作範例使用 @CircuitBreaker annotation123456789@CircuitBreaker(name = &quot;backendB&quot;, fallbackMethod = &quot;fallbackForBackendB&quot;)public String testCBBackendB() { throw new RuntimeException(&quot;backendB fail&quot;);}public String fallbackForBackendB(RuntimeException ex) { log.error(&quot;backendB 發生錯誤：&quot;, ex); return &quot;backendB 的 fallback 回應&quot;;} 注意坑點因為 @CircuitBreaker 是靠 AOP 實作，所以你除了加 resilience4j-spring-boot3 依賴外，也必須記得加上 AOP 相關依賴： 12345678910&lt;dependency&gt; &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt; &lt;artifactId&gt;resilience4j-spring-boot3&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 必須加入 Spring AOP 依賴 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 使用程式碼自訂設定123456789101112131415161718CircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom() .failureRateThreshold(50) .slowCallRateThreshold(50) .waitDurationInOpenState(Duration.ofMillis(1000)) .slowCallDurationThreshold(Duration.ofSeconds(2)) .permittedNumberOfCallsInHalfOpenState(3) .minimumNumberOfCalls(10) .slidingWindowType(SlidingWindowType.TIME_BASED) .slidingWindowSize(5) .recordException(e -&gt; INTERNAL_SERVER_ERROR.equals(getResponse().getStatus())) .recordExceptions(IOException.class, TimeoutException.class) .ignoreExceptions(BusinessException.class, OtherBusinessException.class) .build();CircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry.of(circuitBreakerConfig);CircuitBreaker circuitBreakerWithDefaultConfig = circuitBreakerRegistry.circuitBreaker(&quot;name1&quot;);CircuitBreaker circuitBreakerWithCustomConfig = circuitBreakerRegistry.circuitBreaker(&quot;name2&quot;, circuitBreakerConfig); 結語斷路器是微服務穩定性設計不可或缺的關鍵元件。正確理解狀態切換邏輯、配置核心參數，以及搭配 Bulkhead 等其他保護機制，可有效提升整體系統的容錯力。實作時務必根據自身服務特性調整參數，並留意依賴關係（如 AOP 必須有），才能讓 CircuitBreaker 發揮最大效益！ 如果你有相關的踩坑經驗或參數最佳化建議，歡迎留言一起討論！","link":"/tech/2025/05/18/Java-CircuitBreaker/"}],"tags":[{"name":"Java","slug":"Java","link":"/tech/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tech/tags/Spring-Boot/"},{"name":"Resilience4j","slug":"Resilience4j","link":"/tech/tags/Resilience4j/"},{"name":"微服務","slug":"微服務","link":"/tech/tags/%E5%BE%AE%E6%9C%8D%E5%8B%99/"},{"name":"斷路器","slug":"斷路器","link":"/tech/tags/%E6%96%B7%E8%B7%AF%E5%99%A8/"}],"categories":[],"pages":[]}